# Check Point - Playground

```elixir
Mix.install(
  [
    {:check_point, path: Path.join(__DIR__, ".."), env: :dev},
    {:ecto_sql, "~> 3.0"}
  ],
  config_path: :check_point,
  lockfile: :check_point
)
```

## Database

```elixir
require Ecto.Query
alias CheckPoint.{Checks, Repo}
```

```elixir
Repo.delete_all(Checks.Check)
Repo.delete_all(Checks.Contact)
:ok
```

Create a contact

```elixir
contact = %{
  name: "rbart",
  description: "Randy Bartels",
  type: "email",
  detail: "jrb@codingp.com"
}

{res, my_contact} = Checks.create_contact(contact)
```

Add a check

```elixir
check = %{
  description: "test",
  action: "green",
  args: "",
  name: "rbart",
  contact_id: my_contact.id
}

{res, my_check} = Checks.create_check(check)
```

Now play around with the database

```elixir
Checks.list_contacts() |> Repo.preload(:checks)
```

```elixir
Checks.list_checks() |> Repo.preload(:contact)
```

```elixir
# my_check =
Checks.create_check(%{
  description: "Google",
  action: "red",
  args: "google.com",
  contact_id: my_contact.id
})
```

```elixir
Checks.list_checks(%{contact: %{name: my_contact.name}})
```

```elixir
Checks.create_check(Map.put(check, :contact_id, my_contact.id))
```

## Registery Section

```elixir
Registry.lookup(CheckPoint.WorkerReg, my_check.id)
```

## Escalate Section

```elixir
res = Task.start(CheckPoint.Escalate, :run, ["test"])
```

```elixir
CheckPoint.Escalate.alert(:err, "test", 0)
```

```elixir
Registry.count(CheckPoint.EscalateReg)
```

```elixir
# :sys.get_status(wk)
```

```elixir
# GenServer.stop(wk, :normal)
```

```elixir
# Supervisor.stop(CheckPoint.DynSup)
```

## Worker Section

```elixir
chils = Supervisor.which_children(CheckPoint.DynSup)
```

```elixir
dpid = Process.whereis(CheckPoint.DynSup)
:sys.get_status(dpid)
```

```elixir
for {_, pid, _, _} <- chils, do: :sys.get_state(pid)
```

```elixir
rpid = Process.whereis(CheckPoint.WorkerReg)
:sys.get_state(rpid)
```

```elixir
lis =
  for num <- 0..9 do
    CheckPoint.Worker.check("worker#{num}", fn _x -> :down end, args: 0)
  end
```

```elixir
# wlis =
# for num <- 0..9 do
#  DynamicSupervisor.start_child(
#   CheckPoint.DynSup,
#  {CheckPoint.Worker, val: 0, delay: 5, args: :ip, name: "worker#{num}"}
# )
# end
```

```elixir
[{wk, _} | _] = Registry.lookup(CheckPoint.WorkerReg, "worker0")
```

```elixir
:sys.get_state(wk)
```

## Section

Thoughts on things to add...

querying a check should also return:

is_alive - whether the check process is running

status - the last result of the check

logs - need to query logs

I need two subscription endpoints for alerts:

contact_alert - gets an update when any check for that contact goes into alert

check_alert - gets an update when a single check goes into alert

These also should get updates when an alert clears

Thoughts on things to test...

when a contact is deleted, also delete all checks

change the contact that a check is linked to (actually, checks don't mutate; delete and create a new one)
